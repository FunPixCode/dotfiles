* What are types
  Type is basically a set of values(Bool is a set of values True and False)
* Bottom
  Every type extends a special value called bottom and denoted by âŠ¥.
  This value corresponds to non-terminating computation.
  Function can explicitely return bottom value - undefined.
  f :: Bool -> Bool
  f = undefined
  undefined evaluates to bottom, which is a member of any type including Bool.
* Partial functions
  Functions that return bottom are caller PARTIAL(function is not defined for all possible arguments)
* Total function
  Function that is defined for all possible arguments
* TODO Learn what is operational semantics
  It is hard to prove things about programs using operational semantics.
  To show a property of the program you essentially have to run it throug idealized interpreter.
  Programmers never do formal proofs of program correctness
* TODO Learn what is denotational semantics
  In denotational semantics every programming construct is given its mathematical interpretation.
  With that if you want to prove the property of a program, you just prove a mathematical theorem.
* Pure function
  Function that always produce the same result given the same input and have no side effects are
  called PURE FUNCTIONS.
* Void is an empty set, it has no value
  The function that requires Void as its argument can not be called, because there is no value of type Void.
  However there is a function in haskell:
  absurd :: Void -> a
* TODO Learn what is Curry-Howard isomorphism
* () is a Unit
  A set with only one value, a singleton set
* Parametrically polimorfic function
  Function that can be implemented with the same formula for any type are called parametrically polimorfic.
  Example of function from any type to unit:
  unit :: a -> ()
  unit _ = ()
* Two elements set (category)
  Example:
  data Bool = True | False
* Predicates
  Functions to Bool
* Categories
** No Object category
   Empty category that does not contain any object and morphism.
   (Likea an empty set)
** Simple graphs
   Free caregory generated by a given graph.
** Orders
   A category where the relation btween objects: the relation of being less then or equal.
** Monoid as set
   Monoid is defined as a set with binary operation.
   All that is required for this operation is that it is associative and
   there is some spacial element that behaves like a unit with respect to it.
   For example natural numbers with zero form a monid under addition.
   Associativity means:
   (a + b) + c = a + (b + c)
   Then neutral element is zero because:
   0 + a = a
   a + 0 = a
   In haskell we can define a typeclass for monoid:
   class Monoid m where
       mempty :: m
       mappemd :: m -> m -> m

   instance Monoid String where
       mempty = ""
       mappend = (++)

   A Monoid is a single object category(comes from Greek mono - single)
* Kleisli Categories
  Morphisms from type A to type B are functions that go from A to derived from B
  using the particular embellishment. Each Kleisly category define its own way
  of composing such morphism, as well as the identity morphisms with respect to
  that composition.
* Writer Category
  Our morphisms are functions from arbitrary type to some Writer.
  #+BEGIN_SRC haskell
  type Writer a = (a, String)

  a -> Writer a
  #+END_SRC
  Composition can be declared as infix operator >=>
  #+BEGIN_SRC haskell
  (>=>) :: (a -> Writer b) -> (b -> Writer c) -> (a -> Writer c)
  #+END_SRC
* Isomorphism
  Isomorphism - is an invertible morphism, or a pair of morphisms
  where one is an invers of the other.
  We understand the invers in terms of composition and identity:
  morphism g is the inverse of morphism f if their composition is
  identity morphism.
  Example:
  f . g = id
  g . f = id
